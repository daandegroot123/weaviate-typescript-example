import { DefaultApi } from "./generated/api";
import { Configuration } from "./generated/configuration";
// a function to convert a non-Array object to an Array
function toArray(obj) {
    if (Array.isArray(obj)) {
        return obj;
    }
    else {
        return [obj];
    }
}
// a function to convert an array to array of arrays
function toArrayOfArrays(obj) {
    if (Array.isArray(obj[0])) {
        return obj;
    }
    else {
        return [obj];
    }
}
class EmbeddingFunction {
}
let OpenAIApi;
export class OpenAIEmbeddingFunction {
    constructor(openai_api_key, openai_model, openai_organization_id) {
        try {
            // eslint-disable-next-line global-require,import/no-extraneous-dependencies
            OpenAIApi = require("openai");
        }
        catch (_a) {
            throw new Error("Please install the openai package to use the OpenAIEmbeddingFunction, `npm install -S openai`");
        }
        this.api_key = openai_api_key;
        this.org_id = openai_organization_id || "";
        this.model = openai_model || "text-embedding-ada-002";
    }
    async generate(texts) {
        const configuration = new OpenAIApi.Configuration({
            organization: this.org_id,
            apiKey: this.api_key,
        });
        const openai = new OpenAIApi.OpenAIApi(configuration);
        const embeddings = [];
        const response = await openai.createEmbedding({
            model: "text-embedding-ada-002",
            input: texts,
        });
        const data = response.data['data'];
        for (let i = 0; i < data.length; i += 1) {
            embeddings.push(data[i]['embedding']);
        }
        return embeddings;
    }
}
let CohereAiApi;
export class CohereEmbeddingFunction {
    constructor(cohere_api_key) {
        try {
            // eslint-disable-next-line global-require,import/no-extraneous-dependencies
            CohereAiApi = require("cohere-ai");
        }
        catch (_a) {
            throw new Error("Please install the cohere-ai package to use the CohereEmbeddingFunction, `npm install -S cohere-ai`");
        }
        this.api_key = cohere_api_key;
    }
    async generate(texts) {
        const cohere = CohereAiApi.init(this.api_key);
        const embeddings = [];
        const response = await CohereAiApi.embed({
            texts: texts,
        });
        return response.body.embeddings;
    }
}
export class Collection {
    constructor(name, api, embeddingFunction) {
        this.name = name;
        this.api = api;
        if (embeddingFunction !== undefined)
            this.embeddingFunction = embeddingFunction;
    }
    async add(ids, embeddings, metadatas, documents, increment_index = true) {
        if ((embeddings === undefined) && (documents === undefined)) {
            throw new Error("embeddings and documents cannot both be undefined");
        }
        else if ((embeddings === undefined) && (documents !== undefined)) {
            const documentsArray = toArray(documents);
            if (this.embeddingFunction !== undefined) {
                embeddings = await this.embeddingFunction.generate(documentsArray);
            }
            else {
                throw new Error("embeddingFunction is undefined. Please configure an embedding function");
            }
        }
        if (embeddings === undefined)
            throw new Error("embeddings is undefined but shouldnt be");
        const idsArray = toArray(ids);
        const embeddingsArray = toArrayOfArrays(embeddings);
        let metadatasArray;
        if (metadatas === undefined) {
            metadatasArray = undefined;
        }
        else {
            metadatasArray = toArray(metadatas);
        }
        let documentsArray;
        if (documents === undefined) {
            documentsArray = undefined;
        }
        else {
            documentsArray = toArray(documents);
        }
        if (((embeddingsArray !== undefined) && idsArray.length !== embeddingsArray.length) ||
            ((metadatasArray !== undefined) && idsArray.length !== metadatasArray.length) ||
            ((documentsArray !== undefined) && idsArray.length !== documentsArray.length)) {
            throw new Error("ids, embeddings, metadatas, and documents must all be the same length");
        }
        const response = await this.api.add({
            collectionName: this.name,
            addEmbedding: {
                ids: idsArray,
                embeddings: embeddingsArray,
                documents: documentsArray,
                metadatas: metadatasArray,
                increment_index: increment_index,
            },
        }).then(function (response) {
            return response.data;
        }).catch(function ({ response }) {
            return response.data;
        });
        return response;
    }
    async count() {
        const response = await this.api.count({ collectionName: this.name });
        return response.data;
    }
    async get(ids, where, limit, offset) {
        let idsArray = undefined;
        if (ids !== undefined)
            idsArray = toArray(ids);
        var resp = await this.api.get({
            collectionName: this.name,
            getEmbedding: {
                ids: idsArray,
                where,
                limit,
                offset,
            },
        }).then(function (response) {
            return response.data;
        }).catch(function ({ response }) {
            return response.data;
        });
        return resp;
    }
    async query(query_embeddings, n_results = 10, where, query_text) {
        if ((query_embeddings === undefined) && (query_text === undefined)) {
            throw new Error("query_embeddings and query_text cannot both be undefined");
        }
        else if ((query_embeddings === undefined) && (query_text !== undefined)) {
            const query_texts = toArray(query_text);
            if (this.embeddingFunction !== undefined) {
                query_embeddings = await this.embeddingFunction.generate(query_texts);
            }
            else {
                throw new Error("embeddingFunction is undefined. Please configure an embedding function");
            }
        }
        if (query_embeddings === undefined)
            throw new Error("embeddings is undefined but shouldnt be");
        const query_embeddingsArray = toArrayOfArrays(query_embeddings);
        const response = await this.api.getNearestNeighbors({
            collectionName: this.name,
            queryEmbedding: {
                query_embeddings: query_embeddingsArray,
                where,
                n_results,
            },
        }).then(function (response) {
            return response.data;
        }).catch(function ({ response }) {
            return response.data;
        });
        return response;
    }
    async peek(limit = 10) {
        const response = await this.api.get({
            collectionName: this.name,
            getEmbedding: { limit: limit },
        });
        return response.data;
    }
    async createIndex() {
        return await this.api.createIndex({ collectionName: this.name });
    }
    async delete(ids, where) {
        var response = await this.api._delete({
            collectionName: this.name,
            deleteEmbedding: { ids: ids, where: where },
        }).then(function (response) {
            return response.data;
        }).catch(function ({ response }) {
            return response.data;
        });
        return response;
    }
}
export class ChromaClient {
    constructor(basePath) {
        if (basePath === undefined)
            basePath = "http://localhost:8000";
        const apiConfig = new Configuration({
            basePath,
        });
        this.api = new DefaultApi(apiConfig);
    }
    async reset() {
        return await this.api.reset();
    }
    async createCollection(name, metadata, embeddingFunction) {
        const newCollection = await this.api.createCollection({
            createCollection: { name, metadata },
        }).then(function (response) {
            return response.data;
        }).catch(function ({ response }) {
            return response.data;
        });
        if (newCollection.error) {
            throw new Error(newCollection.error);
        }
        return new Collection(name, this.api, embeddingFunction);
    }
    async listCollections() {
        const response = await this.api.listCollections();
        return response.data;
    }
    async getCollection(name, embeddingFunction) {
        return new Collection(name, this.api, embeddingFunction);
    }
    async deleteCollection(name) {
        const response = await this.api.deleteCollection({ collectionName: name }).then(function (response) {
            return response.data;
        }).catch(function ({ response }) {
            return response.data;
        });
        return response;
    }
}
//# sourceMappingURL=index.js.map